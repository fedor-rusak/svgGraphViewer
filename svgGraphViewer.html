<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>svgGraphViewer 0.22</title>

		<script>
			"use strict";

			//example data with graph like
			// A ---> B ---> C1
			//           `-> C2 --> D1
			//                  `-> D2
			const inputData = [
				{nodeName: "ROOT_NODE", depends:[]},
				{nodeName: "B", depends: ["ROOT_NODE"]},
				{nodeName: "C1", depends: ["B"]},
				{nodeName: "C2", depends: ["B"]},
				{nodeName: "D1", depends: ["C2"]},
				{nodeName: "D2", depends: ["C2"]}
			];
		</script>

		<script>
			"use strict";

			//Graph-like data structure.
			const coreGraph = function() {
				const generateGraphStructure = function() {
					//actual instance state
					var nodeNames = [],
					    nodePropertiesStorage = {},
					    edgeNames = [],
					    edgePropertiesStorage = {};

					const shallowCopy = function(source) {
						return Object.assign({}, source);
					};

					const propertiesAreValid = function(properties) {
						Object.keys(properties).forEach(
							key => {
								if (typeof properties[key] === 'object') {
									throw Error("Only float, string, booleans allowed as properties!!! \n\n\nError with key: "+key+"\nWhole structure: "+JSON.stringify(properties));
								}
							}
						);

						return true;
					}

					const addNode = function(newName, newProperties) {
						newProperties = newProperties || {};

						if (nodePropertiesStorage[newName] === undefined
							&& typeof newProperties === 'object'
							&& propertiesAreValid(newProperties)) {
							nodePropertiesStorage[newName] = shallowCopy(newProperties);
							nodePropertiesStorage[newName]["name"] = newName;
							nodeNames.push(newName);
						}
					}

					const getNode = function(nodeName) {
						return shallowCopy(nodePropertiesStorage[nodeName]);
					}

					const setNodeProperty = function(nodeName, propertyName, propertyValue) {
						if (nodePropertiesStorage[nodeName] === undefined) {
							throw new Error("Attempt to set property for non-existent node. Node name: " + nodeName);
						}

						if (typeof propertyName !== 'string') {
							throw new Error("Only strings allowed as property names. Property name: " + propertyName);
						}

						if (propertyName === "name") {
							throw new Error("Property 'name' can't be modified with this API.");
						}

						if (typeof propertyValue === 'object') {
							throw new Error("Only strings, boolean, floats allowed as property values. Property value: " + JSON.stringify(propertyValue));
						}

						nodePropertiesStorage[nodeName][propertyName] = propertyValue;

						return shallowCopy(nodePropertiesStorage[nodeName]);
					};

					const shallowCopyArray = function(source) {
						return Object.assign([], source);
					};

					const getNodeNames = function() {
						return shallowCopyArray(nodeNames);
					}

					const addEdge = function(newEdgeName, newProperties) {
						if (typeof newEdgeName !== 'string') {
							throw new Error("Invalid edge name. Name: " + newEdgeName );
						}

						if (newProperties === undefined
							|| typeof newProperties !== 'object'
							|| typeof newProperties.from !== 'string'
							|| typeof newProperties.to !== 'string'
							|| !propertiesAreValid(newProperties)) {
							throw new Error("Properties are invalid.");
						}

						if (nodePropertiesStorage[newProperties.from] === undefined
							|| nodePropertiesStorage[newProperties.to] === undefined) {
							throw new Error("Some nodes related to new edge do not exist! From: " +
								newProperties.from + ", to: " + newProperties.to);
						}

						if (edgePropertiesStorage[newEdgeName] === undefined) {
							edgePropertiesStorage[newEdgeName] = shallowCopy(newProperties);
							edgePropertiesStorage[newEdgeName]["name"] = newEdgeName;
							edgeNames.push(newEdgeName);
						}
					};

					const getEdge = function(edgeName) {
						return shallowCopy(edgePropertiesStorage[edgeName]);
					}

					const setEdgeProperty = function(edgeName, propertyName, propertyValue) {
						if (edgePropertiesStorage[edgeName] === undefined) {
							throw new Error("Attempt to set property for non-existent edge. Edge name: " + edgeName);
						}

						if (typeof propertyName !== 'string') {
							throw new Error("Only strings allowed as property names. Property name: " + propertyName);
						}

						if (propertyName === "name"
						    || propertyName === "from"
						    || propertyName === "to") {
							throw new Error("Property '"+propertyName+"' can't be modified with this API.");
						}

						if (typeof propertyValue === 'object') {
							throw new Error("Only strings, boolean, floats allowed as property values. Property value: " + JSON.stringify(propertyValue));
						}

						edgePropertiesStorage[edgeName][propertyName] = propertyValue;

						return shallowCopy(edgePropertiesStorage[edgeName]);
					};

					const getEdgeNames = function() {
						return shallowCopyArray(edgeNames);
					}

					return {
						addNode,
						getNode,
						setNodeProperty,
						getNodeNames,
						addEdge,
						getEdge,
						setEdgeProperty,
						getEdgeNames
					};
				};

				//TESTS
				const wrapperForExceptionThrowingAPICall = function(func, errorMessage) {
					let noException = true;

					try {
						func();
					}
					catch (e) {
						noException = false;
					}

					if (noException) {
						throw new Error(errorMessage);
					}
				}

				try {
					let testGraph = generateGraphStructure();

					let nodeName = "A";
					let nodeDescription = "A node";
					let nodeProperties = {description: nodeDescription};

					testGraph.addNode(nodeName, nodeProperties);
					if (testGraph.getNode(nodeName).description !== nodeDescription) {
						throw new Error("Adding node with properties failed!");
					}

					//someone modified added nodeProperties object
					nodeProperties.description = "NOT A node";
					if (testGraph.getNode(nodeName).description !== nodeDescription) {
						throw new Error("Node properties were modified without proper API call!");
					}

					testGraph.getNode(nodeName).description = "Maybe NOT A node?";
					if (testGraph.getNode(nodeName).description !== nodeDescription) {
						throw new Error("Node properties were modified without proper API call!");
					}

					let secondNodeName = "B";

					testGraph.addNode(secondNodeName, undefined);
					if (testGraph.getNode(secondNodeName).name !== secondNodeName) {
						throw new Error("Adding Node with empty properties failed!");
					}


					wrapperForExceptionThrowingAPICall(
						() => {
							let thirdNodeName = "C";
							let invalidNodeProperties = {description: {description: "Objects NOT allowed as properties!"}};

							testGraph.addNode(thirdNodeName, invalidNodeProperties);
						},
						"Node properties validation failed!"
					);
				}
				catch (e) {
					alert("Adding&Getting Node API failed!\n" + e);
					throw e;
				}

				try {
					let testGraph = generateGraphStructure();

					let nodeName = "A";
					let nodeDescription = "A node";
					let nodeProperties = {description: nodeDescription};
					let newNodeDescription = "A node with new description";


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setNodeProperty(nodeName, "description", newNodeDescription);
						},
						"Setting property for non-existent node is not allowed!"
					);


					//now node must exist in graph
					testGraph.addNode(nodeName, nodeProperties);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setNodeProperty(nodeName, undefined, newNodeDescription);
						},
						"Setting property with undefined name is not allowed!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setNodeProperty(nodeName, {name:"name"}, newNodeDescription);
						},
						"Property name can only be a string!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setNodeProperty(nodeName, "name", "SneakyNewName");
						},
						"Property with name 'name' is not allowed to modify!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setNodeProperty(nodeName, "validPropertyName", {"note": "Objects not allowed!"});
						},
						"Setting property with 'object' value is not allowed!"
					);


					testGraph.setNodeProperty(nodeName, "description", newNodeDescription);
					if (testGraph.getNode(nodeName).description !== newNodeDescription) {
						throw new Error("Settings new value for property of existing node failed!");
					}
				}
				catch (e) {
					alert("setNodeProperty API failed!\n" + e);
					throw e;
				}

				try {
					let testGraph = generateGraphStructure();

					let nodeName = "A";

					testGraph.addNode(nodeName);
					if (testGraph.getNodeNames().length !== 1) {
						throw new Error("Getting node names failed!");
					}

					testGraph.getNodeNames().push("Improper node adding!");
					if (testGraph.getNodeNames().length !== 1) {
						throw new Error("Getting node names encapsulation failed!");
					}
				}
				catch (e) {
					alert("Getting nodeNames API failed!\n" + e);
					throw e;
				}


				try {
					let testGraph = generateGraphStructure();

					let firstNodeName = "A";
					let secondNodeName = "B";
					testGraph.addNode(firstNodeName);
					testGraph.addNode(secondNodeName);
					let edgeName = "A2B";

					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.addEdge(undefined, undefined);
						},
						"Can't add edge with undefined name!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.addEdge({name: "name"}, undefined);
						},
						"Can't add edge with non-string name!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.addEdge(edgeName, undefined);
						},
						"Can't add edge with undefined properties!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.addEdge(edgeName, {from: firstNodeName, to: secondNodeName, data:{}});
						},
						"Can't add edge with with property of 'object' type!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.addEdge(edgeName, {from: "Z", to: secondNodeName});
						},
						"Can't add edge when properties from or/and to point to non-existent node!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.addEdge(edgeName, {from: firstNodeName, to: "Z"});
						},
						"Can't add edge when properties from or/and to point to non-existent node!"
					);


					let edgeProperties = {from: firstNodeName, to: secondNodeName};
					testGraph.addEdge(edgeName, {from: firstNodeName, to: secondNodeName});
					if (testGraph.getEdge(edgeName).from !== firstNodeName) {
						throw new Error("Getting saved edge failed!");
					}

					//attempt to modify properties used during adding
					edgeProperties.from = secondNodeName;
					if (testGraph.getEdge(edgeName).from !== firstNodeName) {
						throw new Error("Keeping edge data encapsulated failed!");
					}

					//attempt to modify result from getting
					testGraph.getEdge(edgeName).from = secondNodeName;
					if (testGraph.getEdge(edgeName).from !== firstNodeName) {
						throw new Error("Keeping get API edge data encapsulated failed!");
					}
				}
				catch (e) {
					alert("Adding&Getting Edge API failed!\n" + e);
					throw e;
				}

				try {
					let testGraph = generateGraphStructure();

					let firstNodeName = "A";
					let secondNodeName = "B";
					let edgeName = "A2B";
					let edgeDescription = "An edge";
					let edgeProperties = {
						from: firstNodeName,
						to: secondNodeName,
						description: edgeDescription
					};
					let newEdgeDescription = "An edge with new description";


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setEdgeProperty(edgeName, "description", newEdgeDescription);
						},
						"Setting property for non-existent edge is not allowed!"
					);


					//now nodes and edge must exist in graph
					testGraph.addNode(firstNodeName);
					testGraph.addNode(secondNodeName);
					testGraph.addEdge(edgeName, edgeProperties);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setEdgeProperty(edgeName, undefined, newEdgeDescription);
						},
						"Setting property with undefined name is not allowed!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setEdgeProperty(edgeName, {name:"name"}, newEdgeDescription);
						},
						"Property name can only be a string!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setEdgeProperty(edgeName, "name", "SneakyNewName");
						},
						"Property with name 'name' is not allowed to modify!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setEdgeProperty(edgeName, "from", "SneakyNewName");
						},
						"Property with name 'from' is not allowed to modify!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setEdgeProperty(edgeName, "to", "SneakyNewName");
						},
						"Property with name 'to' is not allowed to modify!"
					);


					wrapperForExceptionThrowingAPICall(
						() => {
							testGraph.setEdgeProperty(edgeName, "validPropertyName", {"note": "Objects not allowed!"});
						},
						"Setting property with 'object' value is not allowed!"
					);


					testGraph.setEdgeProperty(edgeName, "description", newEdgeDescription);
					if (testGraph.getEdge(edgeName).description !== newEdgeDescription) {
						throw new Error("Settings new value for property of existing edge failed!");
					}
				}
				catch (e) {
					alert("setEdgeProperty API failed!\n" + e);
					throw e;
				}

				try {
					let testGraph = generateGraphStructure();

					let firstNodeName = "A";
					let secondNodeName = "B";
					testGraph.addNode(firstNodeName);
					testGraph.addNode(secondNodeName);
					testGraph.addEdge("A2B", {from: firstNodeName, to: secondNodeName});

					if (testGraph.getEdgeNames().length !== 1) {
						throw new Error("Getting edge names failed!");
					}

					testGraph.getEdgeNames().push("Improper edge adding!");
					if (testGraph.getEdgeNames().length !== 1) {
						throw new Error("Getting edge names encapsulation failed!");
					}
				}
				catch (e) {
					alert("Getting edgeNames API failed!\n" + e);
					throw e;
				}


				//module API
				return {
					generateGraphStructure
				}
			}();
		</script>

		<script>
			"use strict";

			const svgHelper = function() {
				const setSVGAttribute = function(element, name, value) {
					element.setAttributeNS(null, name, value);
				}

				const generateSVGElement = function(name, attributes) {
					var result = document.createElementNS("http://www.w3.org/2000/svg", name);

					if (attributes !== undefined) {
						Object.keys(attributes).forEach(
							key => {
								setSVGAttribute(result, key, attributes[key]);
							}
						);
					}

					return result;
				}

				//module API
				return {
					generateSVGElement,
					setSVGAttribute
				}
			}();
		</script>

		<script>
			"use strict";

			const svgGraphViewer = function() {
				const TEXT_STYLE = "font: 25px Helvetica,sans-serif; text-anchor: middle; user-select: none; -webkit-user-select: none; -moz-user-select: none; cursor: default;";

				let textMeasuringContext = document.createElement("canvas").getContext("2d");
				textMeasuringContext.font = "25px Helvetica,sans-serif";

				const measureText = function(text) {
					return textMeasuringContext.measureText(text).width;
				}

				const ADDITIONAL_TEXT_PADDING = measureText(" ") * 10;

				const BLOCK_HEIGHT = 40;
				const CORNER_RADIUS = 15;
				const DEFAULT_NODE_FILL = "#CCC";

				const renderNode = function(svgRoot, x, y, text) {
					let width = measureText(text) + ADDITIONAL_TEXT_PADDING;

					const backgroundRect = svgHelper.generateSVGElement(
						"rect",
						{
							fill: DEFAULT_NODE_FILL,
							x: x - width/2,
							y: y - BLOCK_HEIGHT/2,
							width: width,
							height: BLOCK_HEIGHT,
							rx: CORNER_RADIUS,
							ry: CORNER_RADIUS
						}
					);

					svgRoot.appendChild(backgroundRect);

					let textElement = svgHelper.generateSVGElement(
						"text",
						{
							style: TEXT_STYLE,
							fill: "#222",
							x,
							y: y+9 //center plus half font height
						}
					);

					let textContent = document.createTextNode(text);
					textElement.appendChild(textContent);

					svgRoot.appendChild(textElement);
				};

				const renderEdge = function(svgRoot, startNode, endNode) {
					const START_X = startNode.x;
					const START_Y = startNode.y;

					const END_X = endNode.x;
					const END_Y = endNode.y;

					//https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
					let pathCode = 
						"M " + START_X + "," +START_Y +
						" " + END_X + "," +END_Y;

					let pathElement = svgHelper.generateSVGElement(
						"path",
						{
							d: pathCode,
							fill: "transparent",
							stroke: "#66A",
							style: "stroke-width: 3"
						}
					);

					svgRoot.appendChild(pathElement);
				}

				const renderGraph = function(svgRoot, coreGraphInstance) {
					coreGraphInstance.getEdgeNames().forEach( 
						edgeName => {
							let edge = coreGraphInstance.getEdge(edgeName);
							let from = coreGraphInstance.getNode(edge.from);
							let to = coreGraphInstance.getNode(edge.to);

							renderEdge(svgRoot, from, to);
						}
					);

					coreGraphInstance.getNodeNames().forEach( 
						nodeName => {
							let node = coreGraphInstance.getNode(nodeName);
							renderNode(svgRoot, node.x, node.y, node.name);
						}
					);
				};

				const setListeners = function(svgRoot, coreGraphInstance) {
					let sharedState = {
						svgRoot,
						graph: coreGraphInstance,
						camera: {
							coords: {
								x: 0,
								y: 0
							}
						},
						mouseState: {
							pressed: false,
							coords: {
								x: undefined,
								y: undefined
							}
						}
					};

					svgRoot.onmousedown = function(event) {
						sharedState.mouseState.pressed = true;
						sharedState.mouseState.coords.x = event.clientX;
						sharedState.mouseState.coords.y = event.clientY;

						console.log("down on " + event.target);
					};

					svgRoot.onmousemove = function(event) {
						if (!sharedState.mouseState.pressed) return;

						let newX = event.clientX;
						let newY = event.clientY;

						let deltaX = sharedState.mouseState.coords.x - newX;
						let deltaY = sharedState.mouseState.coords.y - newY;


						//camera position modification
						let cameraCoords = sharedState.camera.coords;
						cameraCoords.x -= deltaX;
						cameraCoords.y -= deltaY;

						//https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform
						svgHelper.setSVGAttribute(
							sharedState.svgRoot, "transform",
							"translate("+cameraCoords.x+","+cameraCoords.y+")"
						);


						//mouse state update
						sharedState.mouseState.coords.x = newX;
						sharedState.mouseState.coords.y = newY;

						console.log("moved to " + event.clientX +","+event.clientY);
					};

					svgRoot.onmouseup = function() {
						sharedState.mouseState.pressed = false;
						sharedState.mouseState.coords.x = undefined;
						sharedState.mouseState.coords.y = undefined;

						console.log("up");
					};
				}

				//module API
				return {
					renderGraph,
					setListeners
				}
			}();
		</script>

		<script>
			"use strict";

			window.onload = function () {
				try {
					console.log("This is the first step in simple SVG graph Viewr application!" + "\nData: \n" +JSON.stringify(inputData, null, 4));

					//layouting aka assigning coordinates to nodes
					const START_X = 150;
					const START_Y = 50;
					const X_STEP = 200;
					const Y_STEP = 100;
					const MAX_VERTICAL_NODES = 3;

					const graphInstance = coreGraph.generateGraphStructure();
					inputData.forEach( 
						(node, index) => {
							let x = START_X + X_STEP*(Math.floor(index / MAX_VERTICAL_NODES));
							let y = START_Y+Y_STEP*(index % MAX_VERTICAL_NODES);

							graphInstance.addNode(node.nodeName, {x, y});
						}
					);

					//adding edges
					inputData.forEach(
						node => {
							node.depends.forEach(
								ancestorNodeName => {
									let fromNodeName = ancestorNodeName;
									let toNodeName = node.nodeName;
									let edgeName = fromNodeName + "2" + toNodeName;

									graphInstance.addEdge(
										edgeName,
										{from: fromNodeName, to: toNodeName}
									);
								}
							);
						}
					);

					//rendering
					var svgElement = document.querySelector("#svg");
					svgGraphViewer.renderGraph(svgElement, graphInstance);

					//interactivity added
					svgGraphViewer.setListeners(svgElement, graphInstance);
				}
				catch (e) {
					alert("Something went wrong in main setup code!\n\n"+ e);
				}
			};
		</script>
	</head>
	<body style="width:100%;  margin: 0;">
		<svg xmlns="http://www.w3.org/2000/svg" id="svg" style="position:fixed; top:0; left:0; height:100%; width:100% ; user-select: none; -webkit-user-select: none; -moz-user-select: none;"></svg>
	</body>
</html>